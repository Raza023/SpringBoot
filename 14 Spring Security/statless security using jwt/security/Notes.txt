Spring Boot 3.0 Security | Authentication and Authorization | [New Changes] | javaTechie
https://youtu.be/R76S0tfv36w?si=0yP9zJ6pScZmE97d

Add dependencies
security, web, devtools, lombok

1) spring security added.
default username: user
password is generated by app.

2) add username and password using application.properties
spring.security.user.name=admin
spring.security.user.password=admin
#This is for testing purposes, you can not give all the users credentials in properties file.

3) ///////////////////////////Key points///////////////////////////
http.csrf().disable();
CSRF (Cross-Site Request Forgery) is a type of attack that tricks a user into performing actions they didn’t intend to, like submitting a form without their knowledge.
By default, Spring Security enables CSRF protection to prevent this.
http.csrf().disable(); disables that protection.
When to use: Only disable CSRF if you're building a stateless REST API (typically using tokens like JWT), not using browser-based sessions or forms.

http.httpBasic();
This enables HTTP Basic authentication.
It’s a simple way to secure endpoints.
The browser will show a popup to ask for username and password.
Credentials are sent with every request as a Base64 encoded Authorization header:
Authorization: Basic dXNlcjpwYXNzd29yZA==

formLogin();
formLogin() enables form-based authentication, where users log in through a custom HTML login form instead of a popup (like in Basic Auth).
What it does:
Presents a login page (/login) to the user.
Accepts username and password submitted via a form.
Handles login logic, redirection, and error handling.
But you can also use a custom login page:
.formLogin()
    .loginPage("/my-login")
    .permitAll();
For example:
@Override
protected void configure(HttpSecurity http) throws Exception {
    http.csrf().disable()
        .authorizeRequests()
            .antMatchers("/my-login", "/css/**", "/js/**").permitAll() // allow access to login page & static files
            .anyRequest().authenticated()
        .and()
        .formLogin()
            .loginPage("/my-login")               // custom login page URL
            .loginProcessingUrl("/perform-login") // form action URL (Spring handles it internally)  <form th:action="@{/perform-login}" method="post">
            .defaultSuccessUrl("/home", true)     // redirect on successful login
            .failureUrl("/my-login?error=true")   // redirect on login failure
            .permitAll();                         // allow everyone to access the login page
}

Difference between NoOpPasswordEncoder and BCryptPasswordEncoder?
NoOpPasswordEncoder:  It is user for testing.
NoOpPasswordEncoder does no encoding at all — it stores and compares passwords as plain text.
Example:
    @Bean
    public static NoOpPasswordEncoder passwordEncoder() {
        return (NoOpPasswordEncoder) NoOpPasswordEncoder.getInstance();
    }
    String rawPassword = "1234";
    String encodedPassword = "1234"; // same as raw
    boolean match = encoder.matches("1234", "1234"); // true
BCryptPasswordEncoder: It is used for real world application.
Secure, One-Way Hashing Algorithm. It uses bcrypt, a strong hashing algorithm with salt and multiple rounds.
Prevents reverse-engineering the password. Each password hash is unique even if the input is the same (because of salting).
Example:
    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }
    String rawPassword = "1234";
    String encodedPassword = encoder.encode(rawPassword); // hashed!
    System.out.println(encodedPassword);
    // $2a$10$0k1W... <- Looks like random characters
    boolean match = encoder.matches("1234", encodedPassword); // true

4) I need to create config class
In config> create SecurityConfiguration class

Previously before spring boot 3.0 we were using WebSecurityConfigurerAdapter and two overloaded configure methods.
@Configuration
public class SpringSecurityConfig extends WebSecurityConfigurerAdapter {

	///////////////////////////Authentication///////////////////////////
	@Override
	protected void configure(AuthenticationManagerBuilder auth) throws Exception {
		auth.inMemoryAuthentication().withUser("JavaTechie").password(passwordEncoder().encode("Password")).roles("ADMIN");
		auth.inMemoryAuthentication().withUser("Basant").password(passwordEncoder().encode("Password2")).roles("USER");
	}

    ///////////////////////////Authorization///////////////////////////
    // security for all API
	/*
	 * @Override protected void configure(HttpSecurity http) throws Exception {
	 * http.csrf().disable();
	 * http.authorizeRequests().anyRequest().fullyAuthenticated().and().
	 * httpBasic(); }
	 */

	// security based on URL

	/*
	 * @Override protected void configure(HttpSecurity http) throws Exception {
	 * http.csrf().disable();
	 * http.authorizeRequests().antMatchers("/rest/**").fullyAuthenticated().and
	 * ().httpBasic(); }
	 */

	// security based on ROLE
	@Override
	protected void configure(HttpSecurity http) throws Exception {
		http.csrf().disable();
		http.authorizeRequests().antMatchers("/rest/**").hasAnyRole("ADMIN").anyRequest().fullyAuthenticated().and()
				.httpBasic();
	}

	@Bean
	public static NoOpPasswordEncoder passwordEncoder() {
		return (NoOpPasswordEncoder) NoOpPasswordEncoder.getInstance();
	}
}
